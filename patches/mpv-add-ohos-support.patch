diff --git a/audio/out/ao.c b/audio/out/ao.c
index c5d2fb4..dd20c39 100644
--- a/audio/out/ao.c
+++ b/audio/out/ao.c
@@ -48,6 +48,7 @@ extern const struct ao_driver audio_out_pulse;
 extern const struct ao_driver audio_out_jack;
 extern const struct ao_driver audio_out_openal;
 extern const struct ao_driver audio_out_opensles;
+extern const struct ao_driver audio_out_ohaudio;
 extern const struct ao_driver audio_out_null;
 extern const struct ao_driver audio_out_alsa;
 extern const struct ao_driver audio_out_wasapi;
@@ -94,6 +95,9 @@ static const struct ao_driver * const audio_out_drivers[] = {
 #if HAVE_OPENSLES
     &audio_out_opensles,
 #endif
+#if HAVE_OHAUDIO
+    &audio_out_ohaudio,
+#endif
 #if HAVE_SDL2_AUDIO
     &audio_out_sdl,
 #endif
diff --git a/audio/out/ao_ohaudio.c b/audio/out/ao_ohaudio.c
new file mode 100644
index 0000000..f9d623e
--- /dev/null
+++ b/audio/out/ao_ohaudio.c
@@ -0,0 +1,217 @@
+/*
+ * OHAudio audio output driver.
+ *
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ao.h"
+#include "internal.h"
+#include "common/msg.h"
+#include "audio/format.h"
+#include "options/m_option.h"
+#include "osdep/threads.h"
+#include "osdep/timer.h"
+
+#include <ohaudio/native_audiorenderer.h>
+#include <ohaudio/native_audiostreambuilder.h>
+
+struct priv {
+    OH_AudioStreamBuilder* builder;
+    OH_AudioRenderer *renderer;
+    int frame_size;
+
+    int volume_mode;
+};
+
+static void uninit(struct ao* ao)
+{
+    struct priv* p = ao->priv;
+
+    if (p->renderer) {
+        OH_AudioRenderer_Stop(p->renderer);
+        OH_AudioRenderer_Release(p->renderer);
+        p->renderer = NULL;
+    }
+
+    if (p->builder) {
+        OH_AudioStreamBuilder_Destroy(p->builder);
+        p->builder = NULL;
+    }
+}
+
+static OH_AudioData_Callback_Result audio_on_write_callback(
+    OH_AudioRenderer* renderer,
+    void* userData,
+    void* audioData,
+    int32_t audioDataSize)
+{
+    struct ao* ao = userData;
+
+    int sample = audioDataSize / (ao->channels.num * af_fmt_to_bytes(ao->format));
+    double delay = sample / (double)ao->samplerate;
+
+    ao_read_data(ao, &audioData, sample,
+        mp_time_ns() + MP_TIME_S_TO_NS(delay), NULL, true, true);
+
+    return AUDIO_DATA_CALLBACK_RESULT_VALID;
+}
+
+static int init(struct ao* ao)
+{
+    struct priv* p = ao->priv;
+    OH_AudioStream_Result res = 0;
+
+    res = OH_AudioStreamBuilder_Create(&p->builder, AUDIOSTREAM_TYPE_RENDERER);
+
+    if (res != AUDIOSTREAM_SUCCESS) {
+        MP_ERR(ao, "Fail to create audio stream: error code %d.\n", res);
+        goto error;
+    }
+
+    ao->channels.num = MPCLAMP(ao->channels.num, 1, 16);
+    ao->samplerate = MPCLAMP(ao->samplerate, 8000, 192000);
+
+    OH_AudioStreamBuilder_SetChannelCount(p->builder, ao->channels.num);
+    OH_AudioStreamBuilder_SetSamplingRate(p->builder, ao->samplerate);
+    OH_AudioStreamBuilder_SetVolumeMode(p->builder, p->volume_mode);
+    OH_AudioStreamBuilder_SetEncodingType(p->builder, AUDIOSTREAM_ENCODING_TYPE_RAW);
+    OH_AudioStreamBuilder_SetRendererInfo(p->builder, AUDIOSTREAM_USAGE_MOVIE);
+
+    if (af_fmt_is_int(ao->format)) {
+        if (af_fmt_to_bytes(ao->format) > 2)
+            ao->format = AF_FORMAT_S32;
+        else
+            ao->format = af_fmt_from_planar(ao->format);
+    } else {
+        ao->format = AF_FORMAT_FLOAT;
+    }
+
+    switch (ao->format) {
+    case AF_FORMAT_U8:
+        OH_AudioStreamBuilder_SetSampleFormat(p->builder, AUDIOSTREAM_SAMPLE_U8);
+        break;
+    case AF_FORMAT_S16:
+        OH_AudioStreamBuilder_SetSampleFormat(p->builder, AUDIOSTREAM_SAMPLE_S16LE);
+        break;
+    case AF_FORMAT_S32:
+        OH_AudioStreamBuilder_SetSampleFormat(p->builder, AUDIOSTREAM_SAMPLE_S32LE);
+        break;
+    case AF_FORMAT_FLOAT:
+        OH_AudioStreamBuilder_SetSampleFormat(p->builder, AUDIOSTREAM_SAMPLE_F32LE);
+        break;
+    default:
+        OH_AudioStreamBuilder_SetSampleFormat(p->builder, AUDIOSTREAM_SAMPLE_S16LE);
+        break;
+    }
+
+    p->frame_size = ao->samplerate * ao->channels.num * af_fmt_to_bytes(ao->format) * 20 / 1000;
+    OH_AudioStreamBuilder_SetFrameSizeInCallback(p->builder, p->frame_size);
+
+    OH_AudioRenderer_OnWriteDataCallback callback = audio_on_write_callback;
+    OH_AudioStreamBuilder_SetRendererWriteDataCallback(p->builder, callback, ao);
+
+    res = OH_AudioStreamBuilder_GenerateRenderer(p->builder, &p->renderer);
+
+    if (res != AUDIOSTREAM_SUCCESS) {
+        MP_ERR(ao, "Fail to generate audio renderer: error code %d.\n", res);
+        goto error;
+    }
+
+    return 0;
+error:
+    uninit(ao);
+    return -1;
+}
+
+static int control(struct ao *ao, enum aocontrol cmd, void *arg)
+{
+    struct priv *p = ao->priv;
+    float volume;
+    float *vol = arg;
+    OH_AudioStream_Result res = 0;
+
+    switch (cmd) {
+    case AOCONTROL_GET_VOLUME:
+        res = OH_AudioRenderer_GetVolume(p->renderer, &volume);
+        if (res != AUDIOSTREAM_SUCCESS) {
+            MP_ERR(ao, "Fail to get volume, error code %d.\n", res);
+            return CONTROL_ERROR;
+        }
+        *vol = volume * 100;
+        break;
+    case AOCONTROL_SET_VOLUME:
+        res = OH_AudioRenderer_SetVolume(p->renderer, *vol / 100);
+        if (res != AUDIOSTREAM_SUCCESS) {
+            MP_ERR(ao, "Fail to set volume, error code %d.\n", res);
+            return CONTROL_ERROR;
+        }
+        break;
+    default:
+        return CONTROL_UNKNOWN;
+    }
+    return CONTROL_OK;
+}
+
+static void reset(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+
+    OH_AudioRenderer_Stop(p->renderer);
+    OH_AudioRenderer_Flush(p->renderer);
+}
+
+static bool set_pause(struct ao *ao, bool paused)
+{
+    struct priv *p = ao->priv;
+
+    if (paused) {
+        OH_AudioRenderer_Pause(p->renderer);
+    } else {
+        OH_AudioRenderer_Start(p->renderer);
+    }
+    return true;
+}
+
+static void start(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+
+    OH_AudioRenderer_Start(p->renderer);
+}
+
+#define OPT_BASE_STRUCT struct priv
+
+const struct ao_driver audio_out_ohaudio = {
+    .description = "OHAudio audio output",
+    .name      = "ohaudio",
+    .init      = init,
+    .control   = control,
+    .uninit    = uninit,
+    .reset     = reset,
+    .set_pause = set_pause,
+    .start     = start,
+
+    .priv_size = sizeof(struct priv),
+    .priv_defaults = &(const struct priv) {
+        .volume_mode = AUDIOSTREAM_VOLUMEMODE_SYSTEM_GLOBAL,
+    },
+    .options = (const struct m_option[]) {
+        {"volume-mode", OPT_INT(volume_mode),
+            M_RANGE(0, 1)},
+        {0}
+    },
+    .options_prefix = "ohaudio",
+};
diff --git a/meson.build b/meson.build
index 7572769..62a0bc5 100644
--- a/meson.build
+++ b/meson.build
@@ -857,6 +857,13 @@ if features['opensles']
     sources += files('audio/out/ao_opensles.c')
 endif
 
+ohaudio = cc.find_library('ohaudio', required: get_option('ohaudio'))
+features += {'ohaudio': ohaudio.found()}
+if features['ohaudio']
+    dependencies += ohaudio
+    sources += files('audio/out/ao_ohaudio.c')
+endif
+
 oss_opt = get_option('oss-audio').require(
     get_option('gpl'),
     error_message: 'the build is not GPL!',
@@ -1220,6 +1227,12 @@ if features['egl-android']
     sources += files('video/out/opengl/context_android.c')
 endif
 
+egl_ohos = cc.find_library('EGL', required: get_option('egl-ohos'))
+features += {'egl': egl_ohos.found() and gl_allowed}
+if features['egl']
+    dependencies += egl
+endif
+
 egl_drm = get_option('egl-drm').require(
     features['drm'] and features['egl'] and features['gbm'] and gl_allowed,
     error_message: 'either drm, egl, or gbm could not be found!',
diff --git a/meson.options b/meson.options
index dae0a33..ebb7907 100644
--- a/meson.options
+++ b/meson.options
@@ -46,6 +46,7 @@ option('avfoundation', type: 'feature', value: 'auto', description: 'AVFoundatio
 option('jack', type: 'feature', value: 'auto', description: 'JACK audio output')
 option('openal', type: 'feature', value: 'disabled', description: 'OpenAL audio output')
 option('opensles', type: 'feature', value: 'auto', description: 'OpenSL ES audio output')
+option('ohaudio', type: 'feature', value: 'auto', description: 'OHAudio audio output')
 option('oss-audio', type: 'feature', value: 'auto', description: 'OSSv4 audio output')
 option('pipewire', type: 'feature', value: 'auto', description: 'PipeWire audio output')
 option('pulse', type: 'feature', value: 'auto', description: 'PulseAudio audio output')
@@ -62,6 +63,7 @@ option('dmabuf-wayland', type: 'feature', value: 'auto', description: 'dmabuf-wa
 option('drm', type: 'feature', value: 'auto', description: 'Direct Rendering Manager (DRM)')
 option('egl', type: 'feature', value: 'auto', description: 'EGL 1.4')
 option('egl-android', type: 'feature', value: 'auto', description: 'Android EGL support')
+option('egl-ohos', type: 'feature', value: 'auto', description: 'HarmonyOS EGL support')
 option('egl-angle', type: 'feature', value: 'auto', description: 'OpenGL ANGLE headers')
 option('egl-angle-lib', type: 'feature', value: 'auto', description: 'OpenGL Win32 ANGLE library')
 option('egl-angle-win32', type: 'feature', value: 'auto', description: 'OpenGL Win32 ANGLE backend')
